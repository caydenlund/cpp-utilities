/**
 * @file parser.hpp
 * @brief Defines the `parser` class.
 * @details Because this is a template class, implementation is in this file.
 *
 * @author Cayden Lund (cayden.lund@utah.edu)
 *
 * @copyright Copyright (c) 2023 by Cayden Lund.
 * @license MIT License (https://opensource.org/license/mit).
 *
 */

#ifndef PARSER_HPP
#define PARSER_HPP

//  Header includes:
#include "parse_stack.hpp"
#include "production_rule.hpp"
#include "token.hpp"

//  STL includes:
#include <functional>
#include <sstream>
#include <stdexcept>
#include <tuple>
#include <vector>


/*
    ===================
    ||  Definition:  ||
    ===================
*/


/**
 * @brief Parses a series of tokens into an abstract syntax tree.
 * @details
 *
 *     First, an enumeration of all token types and an enumeration of all AST node types
 *     are provided as template parameters.
 *
 *         ```
 *         enum token_type_t {
 *             INT_TOK,     //  `<int>`
 *             PLUS_TOK,    //  `+`
 *             MINUS_TOK,   //  `-`
 *             STAR_TOK,    //  `*`
 *             SLASH_TOK,   //  `/`
 *             LPAREN_TOK,  //  `(`
 *             RPAREN_TOK,  //  `)`
 *             PRINT_TOK    //  `print`
 *         };
 *
 *         enum ast_type_t { EXPR_NODE, PRINT_NODE };
 *
 *         using parser_t = parser<token_type_t, ast_type_t>;
 *         ```
 *
 *     Then, an ordered list of production rules is passed to the constructor.
 *
 *     A production rule is composed as a list of components that make up the rule,
 *     and then the resulting AST node.
 *
 *     This list of production rules is ordered by precedence; for a multiplication to have
 *     precedence over addition, for example, the multiplication rule must come first.
 *
 *     Make a production rule by specifying first the components and then the result:
 *
 *         ```
 *         using production_rule_t = production_rule<token_type_t, ast_type_t>;
 *
 *         const std::vector<production_rule_t> production_rules {
 *             //  `print(<expr>)` --> `<print>`
 *             { { PRINT_TOK, LPAREN_TOK, EXPR_NODE, RPAREN_TOK }, PRINT_NODE },
 *
 *             //  `(<expr>)` --> `<expr>`
 *             { { LPAREN_NODE, EXPR_NODE, RPAREN_NODE }, EXPR_NODE },
 *
 *             //  `<int>` --> `<expr>`
 *             { { INT_NODE }, EXPR_NODE },
 *
 *             //  `<expr> * <expr>` --> `<expr>`
 *             { { EXPR_NODE, STAR_NODE, EXPR_NODE }, EXPR_NODE },
 *
 *             //  `<expr> / <expr>` --> `<expr>`
 *             { { EXPR_NODE, SLASH_NODE, EXPR_NODE }, EXPR_NODE },
 *
 *             //  `<expr> + <expr>` --> `<expr>`
 *             { { EXPR_NODE, PLUS_NODE, EXPR_NODE }, EXPR_NODE },
 *
 *             //  `<expr> - <expr>` --> `<expr>`
 *             { { EXPR_NODE, MINUS_NODE, EXPR_NODE }, EXPR_NODE }
 *         };
 *         ```
 *
 *     Then, instantiate the parser with the list of production rules.
 *
 *         ```
 *         parser_t example_parser(production_rules);
 *         ```
 *
 *     The parser can then parse a series of tokens generated by the lexer into an abstract
 *     syntax tree, as a set of AST nodes.
 *
 *         ```
 *         using token_t = token<token_type_t>;
 *         using ast_node_t = ast_node<token_type_t, ast_type_t>;
 *
 *         const std::string input = "print(1 + 2 * 3 + 4)";
 *         const std::vector<token_t> tokens = example_lexer.lex_string(input);
 *         const std::vector<ast_node_t> ast_nodes = example_parser.parse_tokens(tokens);
 *         ```
 *
 *     AST nodes are parsed in an LR(1) manner according to the given production rules.
 *
 *     First, a stack of tokens and AST nodes is initialized to empty.
 *
 *     At each step, the parser does one of two steps:
 *         1. Shift: push the next token onto the stack.
 *         2. Reduce: if the production items on the top of the stack match any of the production
 *            rules, then perform the production;
 *            pop the items off the stack and push the produced AST node back onto the stack.
 *     The parser decides which of these steps to perform based on the order of the given
 *     production rules.
 *     Walkthrough of the example above, with square brackets for [tokens] and parentheses
 *     for (AST nodes):
 *
 *         Input tokens: [
 *                          PRINT_TOK,
 *                          LPAREN_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          STAR_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: []
 *         First production rule match: `print(<expr>)`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: [
 *                          LPAREN_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          STAR_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK]
 *                      ]
 *         First production rule match: `print(<expr>)`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: [
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          STAR_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK]
 *                      ]
 *         First production rule match: `<int>`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: [
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          STAR_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          [INT_TOK]
 *                      ]
 *         First production rule match: `<int>`
 *         Production rule is complete
 *         Action: reduce
 *
 *
 *         Input tokens: [
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          STAR_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: [INT_TOK])
 *                      ]
 *         First production rule match: `print(<expr>)`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: [
 *                          INT_TOK,
 *                          STAR_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [PLUS_TOK]
 *                      ]
 *         First production rule match: `<expr> + <expr>`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: [
 *                          STAR_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [PLUS_TOK],
 *                          [INT_TOK]
 *                      ]
 *         First production rule match: `<int>`
 *         Production rule is complete
 *         Action: reduce
 *
 *
 *         Input tokens: [
 *                          STAR_TOK,
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [PLUS_TOK],
 *                          (EXPR_NODE: [INT_TOK])
 *                      ]
 *         First production rule match: `<expr> * <expr>`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: [
 *                          INT_TOK,
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [PLUS_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [STAR_TOK]
 *                      ]
 *         First production rule match: `<expr> * <expr>`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: [
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [PLUS_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [STAR_TOK],
 *                          [INT_TOK]
 *                      ]
 *         First production rule match: `<int>`
 *         Production rule is complete
 *         Action: reduce
 *
 *
 *         Input tokens: [
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [PLUS_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [STAR_TOK],
 *                          (EXPR_NODE: [INT_TOK])
 *                      ]
 *         First production rule match: `<expr> * <expr>`
 *         Production rule is complete
 *         Action: reduce
 *
 *
 *         Input tokens: [
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: [INT_TOK]),
 *                          [PLUS_TOK],
 *                          (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                      [STAR_TOK],
 *                                      (EXPR_NODE: [INT_TOK])
 *                          )
 *                      ]
 *         First production rule match: `<expr> + <expr>`
 *         Production rule is complete
 *         Action: reduce
 *
 *
 *         Input tokens: [
 *                          PLUS_TOK,
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                      [PLUS_TOK],
 *                                      (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                  [STAR_TOK],
 *                                                  (EXPR_NODE: [INT_TOK])
 *                                      )
 *                          )
 *                      ]
 *         First production rule match: `print(<expr>)`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: [
 *                          INT_TOK,
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                      [PLUS_TOK],
 *                                      (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                  [STAR_TOK],
 *                                                  (EXPR_NODE: [INT_TOK])
 *                                      )
 *                          ),
 *                          [PLUS_TOK]
 *                      ]
 *         First production rule match: `<expr> + <expr>`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: [
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                      [PLUS_TOK],
 *                                      (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                  [STAR_TOK],
 *                                                  (EXPR_NODE: [INT_TOK])
 *                                      )
 *                          ),
 *                          [PLUS_TOK],
 *                          [INT_TOK]
 *                      ]
 *         First production rule match: `<int>`
 *         Production rule is complete
 *         Action: reduce
 *
 *
 *         Input tokens: [
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                      [PLUS_TOK],
 *                                      (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                  [STAR_TOK],
 *                                                  (EXPR_NODE: [INT_TOK])
 *                                      )
 *                          ),
 *                          [PLUS_TOK],
 *                          (EXPR_NODE: [INT_TOK])
 *                      ]
 *         First production rule match: `<expr> + <expr>`
 *         Production rule is complete
 *         Action: reduce
 *
 *
 *         Input tokens: [
 *                          RPAREN_TOK
 *                       ]
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                  [PLUS_TOK],
 *                                                  (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                              [STAR_TOK],
 *                                                              (EXPR_NODE: [INT_TOK])
 *                                                  )
 *                                      ),
 *                                      [PLUS_TOK],
 *                                      (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                  [PLUS_TOK],
 *                                                  (EXPR_NODE: [INT_TOK])
 *                                      )
 *                          )
 *                      ]
 *         First production rule match: `print(<expr>)`
 *         Production rule is incomplete
 *         Action: shift
 *
 *
 *         Input tokens: []
 *         Parse stack: [
 *                          [PRINT_TOK],
 *                          [LPAREN_TOK],
 *                          (EXPR_NODE: (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                               [PLUS_TOK],
 *                                               (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                      [STAR_TOK],
 *                                                      (EXPR_NODE: [INT_TOK])
 *                                               )
 *                                        ),
 *                                 [PLUS_TOK],
 *                                 (EXPR_NODE: [INT_TOK])
 *                          ),
 *                          [RPAREN_TOK]
 *                      ]
 *         First production rule match: `print(<expr>)`
 *         Production rule is complete
 *         Action: reduce
 *
 *
 *         Input tokens: []
 *         Parse stack: [
 *                          (PRINT_NODE: [PRINT_TOK],
 *                                       [LPAREN_TOK],
 *                                       (EXPR_NODE: (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                            [PLUS_TOK],
 *                                                            (EXPR_NODE: (EXPR_NODE: [INT_TOK]),
 *                                                                   [STAR_TOK],
 *                                                                   (EXPR_NODE: [INT_TOK])
 *                                                            )
 *                                                     ),
 *                                              [PLUS_TOK],
 *                                              (EXPR_NODE: [INT_TOK])
 *                                       ),
 *                                       [RPAREN_TOK]
 *                          )
 *                      ]
 *         Parsing is finished.
 *
 *     An optional generation function can be used to reconstruct an `AstNode`
 *     into any arbitrary type. This is useful when you want to generate instances of
 *     specialized AST node classes.
 *     Such a generation function can greatly simplify the following phases of the compilation
 *     process.
 *
 *         ```
 *         struct foo {
 *             std::string text;
 *         }
 *
 *         foo generate_foo(const ast_node_t& node) {
 *             if (node.is_token()) {
 *                 return foo("[" + node.token().text + "]");
 *             }
 *             std::string result = " { ";
 *             for (const auto& child : node.children()) {
 *                 result += generate_foo(child) + " ";
 *             }
 *             result == "} ";
 *             return foo(result);
 *         }
 *
 *         //  . . .
 *         const std::vector<Foo> foo_nodes = parser.parse_tokens(tokens);
 *         std::cout << foo_nodes[0].text << std::endl;
 *         //  Result: `TODO: This.`
 *         ```
 *
 * @tparam token_type_t An enumeration of all token types.
 * @tparam ast_type_t An enumeration of all AST node types.
 */
template<typename token_type_t, typename ast_type_t>
class parser {
public:
    /**
     * @brief The specialized type of a production rule.
     *
     */
    using production_rule_t = production_rule<token_type_t, ast_type_t>;

    /**
     * @brief The specialized type of a token.
     *
     */
    using token_t = token<token_type_t>;

    /**
     * @brief The specialized type of an AST node.
     *
     */
    using ast_node_t = ast_node<token_type_t, ast_type_t>;

    /**
     * @brief Class constructor.
     *
     * @param production_rule_set The ordered set of production rules for this parser.
     */
    parser(const std::vector<production_rule_t>& production_rule_set);

    /**
     * @brief Parses the given series of tokens into an abstract syntax tree.
     * @details Throws an exception on error.
     *     An optional generation function can be used to reinterpret a `production_item_t` node
     *     into any arbitrary type. This is useful when you want to generate instances of
     *     specialized AST node classes instead of a `production_item_t` node.
     *
     * @tparam node_t The type of an AST node. Defaults to `ast_node_t`.
     * @param tokens The series of tokens to parse.
     * @param node_generator A generation function for AST nodes.
     * @return The abstract syntax tree as a series of the given `node_t` type.
     */
    template<typename node_t = ast_node_t>
    std::vector<node_t> parse_tokens(const std::vector<token_t>& tokens,
                                     const std::function<node_t(const ast_node_t&)>& node_generator
                                     = _node_generator) const;

private:
    /**
     * @brief The default node generation function.
     *
     * @param item An `ast_node_t` instance.
     * @return The same `ast_node_t` instance.
     */
    static ast_node_t _node_generator(const ast_node_t& item);

    /**
     * @brief The set of production rules.
     *
     */
    const std::vector<production_rule_t> _production_rule_set;
};


/*
    =======================
    ||  Implementation:  ||
    =======================
*/

template<typename token_type_t, typename ast_type_t>
parser<token_type_t, ast_type_t>::parser(
        const std::vector<parser::production_rule_t>& production_rule_set)
    : _production_rule_set(production_rule_set) {}

template<typename token_type_t, typename ast_type_t>
template<typename node_t>
std::vector<node_t> parser<token_type_t, ast_type_t>::parse_tokens(
        const std::vector<token_t>& tokens,
        const std::function<node_t(const ast_node_t&)>& node_generator) const {
    parse_stack<token_type_t, ast_type_t> stack;

    for (unsigned long token_index = 0; token_index < tokens.size();) {
        const token_t& token = tokens[token_index];
        bool found_parser = false;
        for (const parser::production_rule_t& rule : _production_rule_set) {
            if (stack.matches_rule(rule)) {
                stack.apply_rule(rule);
                found_parser = true;
                break;
            }
            if (stack.matches_rule_part(tokens[token_index].type, rule)) {
                stack.push({token});
                ++token_index;
                found_parser = true;
                break;
            }
        }
        if (!found_parser) {
            std::stringstream error_message;
            error_message << "Parsing error: unexpected token at " << token.line << ":"
                          << token.column << ": \"" << token.text << "\"";
            throw std::runtime_error(error_message.str());
        }
    }

    //  Apply the final reductions.
    bool reduced = false;
    while (!reduced) {
        reduced = true;

        for (const parser::production_rule_t& rule : _production_rule_set) {
            if (stack.matches_rule(rule)) {
                stack.apply_rule(rule);
                reduced = false;
                break;
            }
        }
    }

    return stack.template generate_nodes<node_t>(node_generator);
}

template<typename token_type_t, typename ast_type_t>
typename parser<token_type_t, ast_type_t>::ast_node_t
parser<token_type_t, ast_type_t>::_node_generator(const ast_node_t& item) {
    return item;
}

#endif
